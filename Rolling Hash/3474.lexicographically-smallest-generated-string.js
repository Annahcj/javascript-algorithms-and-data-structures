// 3474. Lexicographically Smallest Generated String
// You are given two strings, str1 and str2, of lengths n and m, respectively.
// A string word of length n + m - 1 is defined to be generated by str1 and str2 if it satisfies the following conditions for each index 0 <= i <= n - 1:
  // If str1[i] == 'T', the substring of word with size m starting at index i is equal to str2, i.e., word[i..(i + m - 1)] == str2.
  // If str1[i] == 'F', the substring of word with size m starting at index i is not equal to str2, i.e., word[i..(i + m - 1)] != str2.
// Return the lexicographically smallest possible string that can be generated by str1 and str2. If no string can be generated, return an empty string "".


// Solution: Rolling Hash & Deque

// 1. Fill in all substrings where str1[i] = T. 
  // If there are any overlapping characters that don't match, return "".
  // Put underscores for substrings where str1[i] = F.

// 2. Second pass to generate the rolling hash for every substring.
  // Rolling hash gives us the ability to check if adding a character at some index will make a substring equal to str2, in O(1) time complexity.

// 2. Third pass to fill in the underscores.
  // Process underscores from left-to-right.
  // Try to fill each underscore i with either 'a' or 'b'.
  // Go through all previous 'F's whose substrings overlap with the current index i.
  // Since we don't need all previous indices, store previous 'F's in a deque and remove indices smaller than i - m from the left.
  // Go through the m previous F indices and check if the hash with the new character is equal to str2. 
  // If all previous F indices hashes are still not equal to str2's hash after adding the new character, we can fill it with that character.

// Time Complexity: O(nm) 481ms
// Space Complexity: O(n + m) 68.95MB
function generateString(str1, str2) {
  const n = str1.length, m = str2.length;
  const str = Array(n + m - 1).fill('_');
  for (let i = 0; i < n; i++) {
    if (str1[i] === 'T') {
      for (let j = 0; j < m; j++) {
        // overlapping character that is not equal
        if (str[i + j] !== '_' && str[i + j] !== str2[j]) {
          return "";
        }
        str[i + j] = str2[j];
      }
    }
  }
  const MOD = 1000000007, pow = 31, powM = Array(m + 1).fill(1);
  let currPowM = 1;
  for (let i = 0; i < m; i++) {
    currPowM = (currPowM * pow) % MOD;
    powM[i + 1] = currPowM;
  }
  const str2Hash = substrHash(str2, powM, MOD);
  const hash = Array(n);
  for (let i = 0; i < n; i++) {
    const substr = str.slice(i, i + m);
    hash[i] = substrHash(substr, powM, MOD);
    // the substring starting at index i is the same as str2, but shouldn't be
    if (str1[i] === 'F' && hash[i] === str2Hash) return "";
  }
  const deque = new DoubleEndedQueue();
  for (let i = 0; i < str.length; i++) {
    if (str1[i] === 'F') deque.push(i);
    while (!deque.isEmpty() && deque.front() <= i - m) deque.shift();

    if (str[i] === '_') {
      const candidates = ['a', 'b'];
      for (let candidate of candidates) {
        let valid = true, node = deque.frontNode();
        for (let j = 0; j < deque.size; j++) {
          const prevIndex = node.val;
          if (newHash(hash[prevIndex], candidate, i - prevIndex, powM, MOD) === str2Hash) {
            valid = false;
            break;
          }
          node = node.next;
        }
        if (valid) {
          node = deque.frontNode();
          for (let j = 0; j < deque.size; j++) {
            const prevIndex = node.val;
            hash[prevIndex] = newHash(hash[prevIndex], candidate, i - prevIndex, powM, MOD);
            node = node.next;
          }
          str[i] = candidate;
          break;
        }
      }
    }
  }
  return str.join("");
};

function substrHash(substr, powM, MOD) {
  const m = substr.length;
  let hash = 0;
  for (let i = 0; i < m; i++) {
    // omit "_" from the hash, to be added on later when filled with another character.
    if (substr[i] !== '_') {
      hash = (hash + powM[i] * (substr[i].charCodeAt() - 96)) % MOD;
    }
  }
  return hash;
}

function newHash(hash, newChar, index, powM, MOD) {
  const charcode = newChar.charCodeAt() - 96;
  return (hash + powM[index] * charcode) % MOD;
}

class DoubleEndedQueue {
  constructor() {
    this.head = new Node(null);
    this.tail = new Node(null);
    this.head.next = this.tail;
    this.tail.prev = this.head;
    this.size = 0;
  }
  unshift(val) {
    let node = new Node(val);
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
    this.size++;
  }
  push(val) {
    let node = new Node(val);
    node.prev = this.tail.prev;
    node.next = this.tail;
    this.tail.prev.next = node;
    this.tail.prev = node;
    this.size++;
  }
  shift() {
    let head = this.head.next;
    this.removeNode(head);
    this.size--;
    return head.val;
  }
  pop() {
    let tail = this.tail.prev;
    this.removeNode(tail);
    this.size--;
    return tail.val;
  }
  removeNode(node) {
    if (!node.prev && !node.next) return;
    node.prev.next = node.next;
    node.next.prev = node.prev;
    node.prev = null;
    node.next = null;
  }
  frontNode() {
    return this.head.next;
  }
  front() {
    return this.head.next.val;
  }
  back() {
    return this.tail.prev.val;
  }
  isEmpty() {
    return this.size === 0;
  }
}
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}

// Three test cases
console.log(generateString("TFTF", "ab")) // "ababa"
console.log(generateString("TFTF", "abc")) // ""
console.log(generateString("F", "d")) // "a"